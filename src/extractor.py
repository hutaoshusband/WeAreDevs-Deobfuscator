import re
import sys
import subprocess
import os
import shutil

# --- Configuration ---
LUA_INTERPRETERS = ["lua", "lua5.1", "luajit"]
TEMP_FILENAME = "temp_decrypt.lua"

def extract_chunks(content):
    """
    Extracts the String Table, Shuffle Loop, and Decryptor Loop from the obfuscated script.
    """
    # Chunk 1: String Table
    # Looks for 'local var={...}'
    table_pattern = re.compile(r'(local\s+(?P<var>\w+)\s*=\s*\{(?:[^}"\']|"(?:[^"\\]|\\.)*"|\'(?:[^\'\\]|\\.)*\')*\})', re.DOTALL)
    table_match = table_pattern.search(content)

    if not table_match:
        raise ValueError("Could not find String Table (Chunk 1)")

    table_chunk = table_match.group(1)
    table_var = table_match.group('var')
    table_end_pos = table_match.end()

    # Chunk 3 End: Start of VM payload
    # Identified by 'return(function'
    payload_pattern = re.compile(r'return\s*\(\s*function')
    payload_match = payload_pattern.search(content, table_end_pos)

    if not payload_match:
        raise ValueError("Could not find start of VM payload (Chunk 3 end)")

    decryptor_end_pos = payload_match.start()

    # Middle section contains Shuffle (Chunk 2) and Decryptor (Chunk 3)
    middle_section = content[table_end_pos:decryptor_end_pos]

    # Split Shuffle and Decryptor
    # The Decryptor block typically starts with 'do local', separated from the Shuffle loop (end end)
    split_pattern = re.compile(r'\bdo\s+local\b')
    split_match = split_pattern.search(middle_section)

    if split_match:
        shuffle_chunk = middle_section[:split_match.start()]
        decryptor_chunk = middle_section[split_match.start():]
    else:
        # Fallback
        print("[Warning] 'do local' separator not found. Assuming middle section is mixed.")
        shuffle_chunk = middle_section
        decryptor_chunk = ""

    return table_var, table_chunk, shuffle_chunk, decryptor_chunk

def generate_lua_harness(table_var, table_chunk, shuffle_chunk, decryptor_chunk):
    """
    Generates a temporary Lua script to run the decryption logic and dump the strings.
    """
    lua_code = f"""
-- Generated by extractor.py
-- Chunk 1: The String Table
{table_chunk}

-- Chunk 2: The Shuffle Loop
{shuffle_chunk}

-- Chunk 3: The Decryptor
{decryptor_chunk}

-- 4. Dump the table
local targetTable = {table_var}

print("--- Decrypted Strings Start ---")
if type(targetTable) == 'table' then
    -- Use ipairs to guarantee order 1..N
    for k, v in ipairs(targetTable) do
        -- Escape newlines to keep one string per line in output
        local s = tostring(v)
        s = string.gsub(s, "\\n", "\\\\n")
        print("[" .. k .. "] " .. s)
    end
else
    print("Error: Target variable '" .. "{table_var}" .. "' is not a table.")
end
print("--- Decrypted Strings End ---")
"""
    return lua_code

def is_noise(s):
    """
    Heuristic to determine if a string is 'noise' (garbage/binary).
    """
    if not s: return True

    # Check for excessive non-printable characters
    non_printable = sum(1 for c in s if not (32 <= ord(c) <= 126))
    if len(s) > 0 and (non_printable / len(s)) > 0.3:
        return True

    # Check for very short random strings (length 1-2) that are not digits/letters
    if len(s) <= 2 and not s.isalnum():
         return True

    return False

def analyze_output(stdout_data):
    """
    Parses the Lua output, filters noise, reconstructs URLs, and highlights targets.
    """
    lines = stdout_data.splitlines()
    decrypted_strings = []

    pattern = re.compile(r'^\[(\d+)\] (.*)$')

    in_block = False

    print("-" * 60)
    print("DEOBFUSCATION REPORT")
    print("-" * 60)

    for line in lines:
        if "--- Decrypted Strings Start ---" in line:
            in_block = True
            continue
        if "--- Decrypted Strings End ---" in line:
            in_block = False
            continue

        if in_block:
            match = pattern.match(line)
            if match:
                idx = int(match.group(1))
                val = match.group(2)
                decrypted_strings.append((idx, val))

    # Filter and Highlight
    clean_strings = []
    potential_url_parts = []

    for idx, val in decrypted_strings:
        if is_noise(val):
            # Skip printing noise, but keep track if needed
            continue

        label = ""

        # Check for Targets
        if "System bereit" in val:
            label = "[TARGET FOUND] "
        elif "http" in val or "pastebin" in val or "raw" in val or "luavm" in val:
            label = "[URL PART] "
            potential_url_parts.append((idx, val))
        elif re.match(r'^[A-Za-z0-9]{10,25}$', val):
            # ID-like string (e.g. BIeF9kqxoNq8)
            label = "[KEY/ID] "

        clean_strings.append(f"{label}[{idx}] {val}")

    # Print Clean Strings
    if clean_strings:
        print("Meaningful Strings Found:")
        for s in clean_strings:
            print(f"  {s}")
    else:
        print("No meaningful strings found (all filtered as noise).")

    # Smart Reconstruction
    if len(potential_url_parts) > 1:
        print("\nSmart Reconstruction (Potential URLs):")
        # Sort by index
        potential_url_parts.sort(key=lambda x: x[0])

        # Check for adjacency
        joined = []
        current_group = []
        last_idx = -2

        for idx, val in potential_url_parts:
            if idx == last_idx + 1:
                current_group.append(val)
            else:
                if current_group:
                    joined.append("".join(current_group))
                current_group = [val]
            last_idx = idx
        if current_group:
            joined.append("".join(current_group))

        for j in joined:
            if "http" in j:
                print(f"  -> {j}")

    print("-" * 60)

def main():
    if len(sys.argv) < 2:
        print("Usage: python3 extractor.py <obfuscated_file.lua>")
        sys.exit(1)

    filepath = sys.argv[1]

    if not os.path.exists(filepath):
        print(f"Error: File '{filepath}' not found.")
        sys.exit(1)

    try:
        with open(filepath, 'r', encoding='latin1') as f:
            content = f.read()

        table_var, chunk1, chunk2, chunk3 = extract_chunks(content)

        print(f"Detected String Table Variable: {table_var}")

        harness_code = generate_lua_harness(table_var, chunk1, chunk2, chunk3)

        with open(TEMP_FILENAME, 'w', encoding='utf-8') as f:
            f.write(harness_code)

        # Find Lua
        lua_exec = None
        for cmd in LUA_INTERPRETERS:
            if shutil.which(cmd):
                lua_exec = shutil.which(cmd)
                break

        if lua_exec:
            # print(f"Running with {lua_exec}...")
            result = subprocess.run([lua_exec, TEMP_FILENAME], capture_output=True)
            output = result.stdout.decode('utf-8', errors='replace')

            if result.stderr:
                print("Lua Error/Warning:")
                print(result.stderr.decode('utf-8', errors='replace'))

            # Analyze and Print
            analyze_output(output)

        else:
            print("Error: Lua interpreter not found in PATH.")
            print(f"Please run 'lua {TEMP_FILENAME}' manually.")

    except Exception as e:
        print(f"Error: {e}")
        # Clean up
        if os.path.exists(TEMP_FILENAME):
            os.remove(TEMP_FILENAME)
        sys.exit(1)
    finally:
        # Clean up
        if os.path.exists(TEMP_FILENAME):
            os.remove(TEMP_FILENAME)

if __name__ == "__main__":
    main()
